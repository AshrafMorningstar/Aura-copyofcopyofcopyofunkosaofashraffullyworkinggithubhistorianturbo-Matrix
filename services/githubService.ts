/**
 * @license
 * Copyright Â© 2026 Ashraf Morningstar
 * https://github.com/AshrafMorningstar
 * 
 * Licensed under the MIT License.
 * This is a personal educational recreation.
 * Original concepts remain property of their respective creators.
 * 
 * @author Ashraf Morningstar
 * @see https://github.com/AshrafMorningstar
 */
import { ActivityType, GeneratedItem } from "../types";
import { CONTRIBUTORS } from "../constants";

const BASE_URL = "https://api.github.com";

interface GithubAuth {
  token: string;
  owner: string;
  repo: string;
}

// Ensure AshrafMorningstar is included with the specific email requested
// Selects 1-2 co-authors total (Ashraf + optional 0-1 others)
const pickCoAuthors = () => {
  const heroName = "AshrafMorningstar";
  const heroEmail = "AshrafMorningstar@users.noreply.github.com";

  // Find hero and others
  const heroSource = CONTRIBUTORS.find(c => c.name === heroName);
  const others = CONTRIBUTORS.filter(c => c.name !== heroName);

  // Prepare Hero Object (checking existence, otherwise creating fallback)
  const hero = heroSource 
    ? { ...heroSource, email: heroEmail } 
    : { name: heroName, role: "Pair Extraordinaire", speed: "fast" as const, email: heroEmail };

  // Randomly pick 0-1 others
  const shuffled = [...others].sort(() => 0.5 - Math.random());
  const selectedOthers = shuffled.slice(0, Math.random() > 0.5 ? 1 : 0);
  
  // Always return Hero + Selected Others
  return [hero, ...selectedOthers];
};

// Helper for authorized fetch
const ghFetch = async (url: string, method: string, token: string, body?: any) => {
  const headers: HeadersInit = {
    "Authorization": `token ${token}`,
    "Accept": "application/vnd.github.v3+json",
    "Content-Type": "application/json",
  };
  
  const response = await fetch(url, {
    method,
    headers,
    body: body ? JSON.stringify(body) : undefined
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.message || `GitHub API Error: ${response.status}`);
  }

  return response.json();
};

export const verifyRepo = async (token: string, repoFullName: string) => {
  const [owner, repo] = repoFullName.split('/');
  if (!owner || !repo) throw new Error("Invalid repo format. Use owner/repo");
  
  try {
    const data = await ghFetch(`${BASE_URL}/repos/${owner}/${repo}`, 'GET', token);
    return { owner, repo, data };
  } catch (e: any) {
    throw new Error(`Repo not found or inaccessible: ${e.message}`);
  }
};

export const createRealIssue = async (auth: GithubAuth, item: Partial<GeneratedItem>): Promise<GeneratedItem> => {
  const coAuthors = pickCoAuthors();
  
  // Mention them in the issue body using '@' mentions
  const mentions = coAuthors.map(c => `@${c.name}`).join(' ');
  const footer = mentions ? `\n\n**Co-authors:** ${mentions}` : '';

  const url = `${BASE_URL}/repos/${auth.owner}/${auth.repo}/issues`;
  const body = {
    title: item.title,
    body: item.description + `\n\n*Generated by GitHub Historian Turbo*${footer}`,
    labels: ['turbo-bot']
  };

  const res = await ghFetch(url, 'POST', auth.token, body);
  
  return {
    ...item,
    id: res.number,
    status: 'created',
    url: res.html_url,
    type: ActivityType.ISSUE,
    timestamp: new Date().toISOString(),
    author: res.user.login,
    coAuthors: coAuthors.map(c => c.name)
  } as GeneratedItem;
};

export const createRealCommit = async (auth: GithubAuth, item: Partial<GeneratedItem>): Promise<GeneratedItem> => {
  const coAuthors = pickCoAuthors();
  
  // 1. Get Main Branch SHA
  const mainRef = await ghFetch(`${BASE_URL}/repos/${auth.owner}/${auth.repo}/git/ref/heads/main`, 'GET', auth.token)
    .catch(async () => await ghFetch(`${BASE_URL}/repos/${auth.owner}/${auth.repo}/git/ref/heads/master`, 'GET', auth.token));
  
  const baseSha = mainRef.object.sha;
  
  // 2. Create File (Commit) directly on main (simulating a direct push)
  const filePath = `turbo-log/commit-${Date.now()}-${Math.floor(Math.random() * 1000)}.md`;
  const content = btoa(`# ${item.title}\n\n${item.description}\n\nGenerated by Turbo Bot`);
  
  // Generate trailers
  const trailers = coAuthors.map(c => `Co-authored-by: ${c.name} <${c.email}>`).join('\n');
  const commitMessage = `chore: ${item.title}\n\n${trailers}`;

  const res = await ghFetch(`${BASE_URL}/repos/${auth.owner}/${auth.repo}/contents/${filePath}`, 'PUT', auth.token, {
    message: commitMessage,
    content: content,
    branch: mainRef.ref.replace('refs/heads/', '') // Push to main/master directly
  });

  return {
    ...item,
    id: res.content.sha.substring(0, 7),
    status: 'created',
    url: res.content.html_url,
    type: ActivityType.COMMIT,
    timestamp: new Date().toISOString(),
    author: "Direct Push",
    coAuthors: coAuthors.map(c => c.name)
  } as GeneratedItem;
}

export const createRealPR = async (auth: GithubAuth, item: Partial<GeneratedItem>): Promise<GeneratedItem> => {
  const coAuthors = pickCoAuthors();

  // 1. Get Main Branch SHA
  const mainRef = await ghFetch(`${BASE_URL}/repos/${auth.owner}/${auth.repo}/git/ref/heads/main`, 'GET', auth.token)
    .catch(async () => await ghFetch(`${BASE_URL}/repos/${auth.owner}/${auth.repo}/git/ref/heads/master`, 'GET', auth.token));
  
  const baseSha = mainRef.object.sha;
  const branchName = `feature/turbo-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

  // 2. Create Branch
  await ghFetch(`${BASE_URL}/repos/${auth.owner}/${auth.repo}/git/refs`, 'POST', auth.token, {
    ref: `refs/heads/${branchName}`,
    sha: baseSha
  });

  // 3. Create File (Commit) with Co-Authored-By trailers
  const filePath = `turbo-gen/${branchName}.md`;
  const content = btoa(`# ${item.title}\n\n${item.description}\n\nGenerated by Turbo Bot`);
  
  // Generate trailers for commit message (This puts the badge/credit in the commit)
  const trailers = coAuthors.map(c => `Co-authored-by: ${c.name} <${c.email}>`).join('\n');
  const commitMessage = `feat: ${item.title}\n\n${trailers}`;

  await ghFetch(`${BASE_URL}/repos/${auth.owner}/${auth.repo}/contents/${filePath}`, 'PUT', auth.token, {
    message: commitMessage,
    content: content,
    branch: branchName
  });

  // 4. Open PR with body mentions (This adds visual credit in the PR UI)
  const mentions = coAuthors.map(c => `@${c.name}`).join(' ');
  const prBodyMentions = mentions ? `\n\n**Co-authors:** ${mentions}` : '';

  const prRes = await ghFetch(`${BASE_URL}/repos/${auth.owner}/${auth.repo}/pulls`, 'POST', auth.token, {
    title: item.title,
    body: item.description + prBodyMentions,
    head: branchName,
    base: mainRef.ref.replace('refs/heads/', '')
  });

  return {
    ...item,
    id: prRes.number,
    status: 'created',
    url: prRes.html_url,
    type: ActivityType.PR,
    timestamp: new Date().toISOString(),
    author: prRes.user.login,
    coAuthors: coAuthors.map(c => c.name)
  } as GeneratedItem;
};

export const mergePR = async (auth: GithubAuth, prNumber: number) => {
  const url = `${BASE_URL}/repos/${auth.owner}/${auth.repo}/pulls/${prNumber}/merge`;
  await ghFetch(url, 'PUT', auth.token, {
    merge_method: 'merge' // 'merge' preserves commit history and trailers better than squash in some views, but squash is also fine if message is kept.
  });
};